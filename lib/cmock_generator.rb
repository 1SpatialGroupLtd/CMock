# ==========================================
#   CMock Project - Automatic Mock Generation for C
#   Copyright (c) 2007 Mike Karlesky, Mark VanderVoord, Greg Williams
#   [Released under MIT License. Please refer to license.txt for details]
# ========================================== 

$here = File.dirname __FILE__

class CMockGenerator

  attr_accessor :config, :file_writer, :module_name, :mock_name, :utils, :plugins, :ordered, :api
  
  #
  #
  #
  #
  #
  def initialize(config, file_writer, utils, plugins, api)
    @file_writer = file_writer
    @utils       = utils
    @plugins     = plugins
    @config      = config
    @prefix      = @config.mock_prefix
    @ordered     = @config.enforce_strict_ordering
    @framework   = @config.framework.to_s
    @api = api
    
    @includes_h_pre_orig_header  = (@config.includes || @config.includes_h_pre_orig_header || []).map{|h| h =~ /</ ? h : "\"#{h}\""}
    @includes_h_post_orig_header = (@config.includes_h_post_orig_header || []).map{|h| h =~ /</ ? h : "\"#{h}\""}
    @includes_c_pre_header       = (@config.includes_c_pre_header || []).map{|h| h =~ /</ ? h : "\"#{h}\""}
    @includes_c_post_header      = (@config.includes_c_post_header || []).map{|h| h =~ /</ ? h : "\"#{h}\""}
  end

  #
  #
  #
  #
  #
  def create_mock(module_name, defnfile, parsed_stuff, target_folder, initialiseFunctions, verifyFunctions)
    @module_name = module_name
    @mock_name   = @prefix + @module_name
    create_mock_header_file(parsed_stuff, defnfile, target_folder, initialiseFunctions, verifyFunctions)
    create_mock_source_file(parsed_stuff, target_folder)
  end
  
  #
  #
  # Function to copy the file and do light parsing
  #
  #
  def copy_header(module_name, parsed_stuff, target_folder)
    @module_name = module_name
    @mock_name   = @prefix + @module_name
    @file_writer.create_file(@mock_name + ".h", target_folder) do |file, filename|
      file << parsed_stuff
    end
  end
  
  private if $ThisIsOnlyATest.nil? ##############################

  #
  #
  #
  #
  #
  def create_mock_header_file(parsed_stuff, defnfile, target_folder, initialiseFunctions, verifyFunctions)
    @file_writer.create_file(@mock_name + ".h", target_folder) do |file, filename|
      create_mock_header_header(file, filename, defnfile, parsed_stuff[:includes])
      create_mock_header_service_call_declarations(file, initialiseFunctions, verifyFunctions)
      create_typedefs(file, parsed_stuff[:typedefs])
      parsed_stuff[:functions].each do |function|
        file << @plugins.run(:mock_function_declarations, function)
      end
      if !(parsed_stuff[:functions].length == 0)
        create_mock_header_footer(file, filename)
      else
        end_definition(file)
      end
    end
  end

  #
  #
  #
  #
  #
  def create_mock_source_file(parsed_stuff, target_folder)
    @file_writer.create_file(@mock_name + ".c", target_folder) do |file, filename|
      create_source_header_section(file, filename)
      create_instance_structure(file, filename, parsed_stuff[:functions])
      create_extern_declarations(file)
      create_mock_verify_function(file, filename, parsed_stuff[:functions])
      create_mock_init_function(file)
      create_mock_destroy_function(file, filename, parsed_stuff[:functions])
      parsed_stuff[:functions].each do |function|
        create_mock_implementation(file, function)
        create_mock_interfaces(file, function)
      end
      # Closing statement for certain files.
      file << source_footer(filename)
    end
  end

  #
  #
  #
  #
  #
  def create_mock_header_header(file, filename, defnfile, includes) 

    orig_filename = filename.gsub(@config.mock_prefix, "")   
    defineName = filename.gsub(".h", "").upcase
    file << "/* AUTOGENERATED FILE. DO NOT EDIT. */\n"
    file << "#ifndef mock_#{defineName}\n"
    file << "#define mock_#{defineName}\n"
    @includes_h_pre_orig_header.each {|inc| file << "#include #{inc}\n"}
    file << "#include \"exportDeclaration.h\"\n\n"

    # Code here to specify certain required includes
    if (filename.match("audit_intrinsics.h"))
      file << "#include \"main_vded_defns.h\"\n"
    elsif (filename.match("gate_intrinsics.h"))
      file << "#include \"iq_defns.h\"\n"
    elsif (filename.match("gdm_intrinsics.h"))
      file << "#include \"plot_defns.h\"\n"
      file << "#include \"rep_defns.h\"\n"
    elsif (filename.match("rastapi_intrinsics.h"))
      file << "#include \"lsr_defns.h\"\n"
    elsif (filename.match("rastcomb_intrinsics.h"))
      file << "#include \"lsr_defns.h\"\n"
    elsif (filename.match("rastdb_intrinsics.h"))
      file << "#include \"lsr_defns.h\"\n"
    elsif (filename.match("rastfile_intrinsics.h"))
      file << "#include \"lsr_defns.h\"\n"
    elsif (filename.match("segtopo_intrinsics.h"))
      file << "#include \"obj_defns.h\"\n"
    end
    # End of hardcoded required includes

    file << "#{defnfile}\n"

    includes.each do |include|
      if (include.match("#include \"#{defnfile}\""))
        #removed - now do nothing
      elsif (include.match("#include \"\""))
        #removed - now do nothing
      else
        file << "#{include}\n"
      end
    end

    @includes_h_post_orig_header.each {|inc| file << "#include #{inc}\n"}
    plugin_includes = @plugins.run(:include_files)
    file << plugin_includes if (!plugin_includes.empty?)
    file << "\n"

    file << "#include \"unity_internals.h\"\n\n"
  end

  #
  #
  #
  #
  #
  def create_typedefs(file, typedefs)
    file << "/* typedefs */"
    typedefs.each {|typedef| file << "#{typedef}\n" }
    file << "\n\n"
  end

  #
  #
  #
  #
  #
  def create_mock_header_service_call_declarations(file, initialiseFunctions, verifyFunctions) 
    file << "#{@api} void #{@mock_name}_Init(void);\n"
    file << "#{@api} void #{@mock_name}_Destroy(void);\n"
    file << "int #{@mock_name}_Verify(void);\n\n"

    initialiseFunctions << "#{@mock_name}_Init()"
    verifyFunctions << "#{@mock_name}_Verify()"
  end

  #
  #
  #
  #
  #
  def create_mock_header_footer(header, filename)

    # Endif as we are manually including an extra defines declaration
    #header << "#endif\n"

    if !(filename.match("revisebase_intrinsics.h"))
      #header << "\n#endif\n"
      end_definition(header)
      #twice as we are adding manual ifdefs to mocks
      end_definition(header)
    else
      end_definition(header)
    end
    
    # Hardcoded endifs for those files with additional ifdefs.
    if (filename.match("main_intrinsics.h"))
      header << "#endif\n"
    elsif (filename.match("objx_intrinsics.h"))
      header << "#endif\n"
    elsif (filename.match("stat_intrinsics.h"))
      header << "#endif\n"
    end
  end

  #
  #
  #
  #
  #
  def end_definition(header)
    header << "\n#endif\n"
  end

  #
  #
  #
  #
  #
  def create_source_header_section(file, filename)
    header_file = filename.gsub(".c",".h")
    file << "/* AUTOGENERATED FILE. DO NOT EDIT. */\n\n"

    # Hardcoded includes, included as whole rather than as needed.
    file << "#include <string.h>\n"
    file << "#include <stdlib.h>\n"
    file << "#include <setjmp.h>\n\n"
    file << "#include \"goth_defns.h\"\n"
    file << "#include \"gothic_status_codes.h\"\n"
    file << "#include \"goth_config.h\"\n"
    file << "#include \"goth_datatypes.h\"\n"
    file << "#include \"goth_streams.h\"\n"
    file << "#include \"goth_intrinsics.h\"\n"

    file << "#include \"#{@framework}.h\"\n"
    file << "#include \"cmock.h\"\n"
    @includes_c_pre_header.each {|inc| file << "#include #{inc}\n"}
    file << "#include \"#{header_file}\"\n"
    @includes_c_post_header.each {|inc| file << "#include #{inc}\n"}
    file << "\n"

  end

  #
  #
  #
  #
  #
  def source_footer(filename)

    source = ''

    # Hardcoded endifs for those files with additional ifdefs.
    if (filename.match("main_intrinsics.c"))
      source << "#endif\n"
    elsif (filename.match("objx_intrinsics.c"))
      source << "#endif\n"
    end

    return source
  end

  #
  #
  #
  #
  #
  def create_instance_structure(file, filename, functions)

    typedef_function_names = []
    staticstruct_function_names = []

    functions.each do |function|

      # Set preprocessor definitions.
      definition = preprocessor_formatting(function)
      file_name = filename_format(function)

      # This check is designed to remove the #ifndef FILENAME that begins each file.
      if !(definition.include?(file_name))
        file << "#{definition}\n"
      end

      file << "typedef struct _CMOCK_#{function[:name]}_CALL_INSTANCE\n{\n"
      file << "  UNITY_LINE_TYPE LineNumber;\n"
      file << @plugins.run(:instance_typedefs, function)
      file << "\n} CMOCK_#{function[:name]}_CALL_INSTANCE;\n\n"

      file << "struct _CMOCK_#{function[:name]}_EXPECT_RESULT\n{\n"
      file << "  int ExpectCalled;\n"
      file << @plugins.run(:expect_arguments, function)
      file << "  char* Function_name;\n"
      file << "\n} CMOCK_#{function[:name]}_EXPECT_RESULT;\n\n"

    end

    # Closing statement for certain files.
    file << source_footer(filename)

    file << "static struct #{@mock_name}Instance\n{\n"
    if (functions.size == 0)
      file << "  unsigned char placeHolder;\n"
    end

    functions.each do |function|

      # Set preprocessor definitions.
      definition = preprocessor_formatting(function)
      file_name = filename_format(function)

      # This check is designed to remove the #ifndef FILENAME that begins each file.
      if !(definition.include?(file_name))
        file << "  #{definition}\n"
      end

      file << @plugins.run(:instance_structure, function)
      file << "  CMOCK_MEM_INDEX_TYPE #{function[:name]}_CallInstance;\n"

    end

    # Closing statement for certain files.
    file << source_footer(filename)

    file << "} Mock;\n\n"

  end

  #
  #
  #
  #
  #
  def create_extern_declarations(file)
    file << "extern jmp_buf AbortFrame;\n"
    if (@ordered)
      file << "extern int GlobalExpectCount;\n"
      file << "extern int GlobalVerifyOrder;\n"
    end
    file << "\n"
  end

  #
  #
  #
  #
  #
  def create_mock_verify_function(file, filename, functions)
    file << "int #{@mock_name}_Verify(void)\n{\n"
    verifications = functions.collect {|function| @plugins.run(:mock_verify, function)}.join
    file << "  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;\n" unless verifications.empty?
    file << verifications
    # Closing statement for certain files.
    file << source_footer(filename)
    file << "  return 0;"
    file << "}\n\n"
  end

  #
  #
  #
  #
  #
  def create_mock_init_function(file)
    file << "#{@api} void #{@mock_name}_Init(void)\n{\n"
    file << "  #{@mock_name}_Destroy();\n"
    file << "}\n\n"
  end

  #
  #
  #
  #
  #
  def create_mock_destroy_function(file, filename, functions)
    file << "#{@api} void #{@mock_name}_Destroy(void)\n{\n"
    file << "  CMock_Guts_MemFreeAll();\n"
    file << "  memset(&Mock, 0, sizeof(Mock));\n"
    file << functions.collect {|function| @plugins.run(:mock_destroy, function)}.join
    if (@ordered)
      file << "  GlobalExpectCount = 0;\n"
      file << "  GlobalVerifyOrder = 0;\n"
    end

    # Closing statement for certain files.
    file << source_footer(filename)

    file << "}\n\n"
  end

  #
  #
  #
  #
  #
  def create_mock_implementation(file, function)        
    # prepare return value and arguments       
    function_mod_and_rettype = (function[:modifier].empty? ? '' : "#{function[:modifier]} ") +
                               (function[:return][:type]) +
                               (function[:c_calling_convention] ? " #{function[:c_calling_convention]}" : '')
    args_string = function[:args_string]
    args_string += (", " + function[:var_arg]) unless (function[:var_arg].nil?)

    definition = preprocessor_formatting(function)

    file_name = filename_format(function)
    if !(definition.include?(file_name))
      file << "#{definition}\n"
    end

    file << "#{@api} #{function[:return][:type]} #{function[:name]}(#{args_string})\n"
    file << "{\n"
    file << "  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;\n"
    file << "  CMOCK_#{function[:name]}_CALL_INSTANCE* cmock_call_instance = (CMOCK_#{function[:name]}_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.#{function[:name]}_CallInstance);\n"
    file << "  Mock.#{function[:name]}_CallInstance = CMock_Guts_MemNext(Mock.#{function[:name]}_CallInstance);\n"
    #file << "  CMOCK_#{function[:name]}_EXPECT_RESULT.ExpectCalled = 0;\n"
    if (function[:var_arg].nil?)
        file << @plugins.run(:mock_implementation_precheck, function) # Shouldn't run if there are variable arguments
    end
    file << "  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, \"Function '#{function[:name]}' called more times than expected.\");\n"
    file << "  cmock_line = cmock_call_instance->LineNumber;\n"
    if (@ordered)
      file << "  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)\n"
      file << "    UNITY_TEST_FAIL(cmock_line, \"Function '#{function[:name]}' called earlier than expected.\");\n"
      file << "  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)\n"
      file << "    UNITY_TEST_FAIL(cmock_line, \"Function '#{function[:name]}' called later than expected.\");\n"
    end
    file << @plugins.run(:mock_implementation, function)
    func_return_type = function[:return][:type]
    if !(func_return_type.match("GOTH_OBJECT_ID"))
      file << "  return (#{function[:return][:type]})cmock_call_instance->ReturnVal;\n" unless (function[:return][:void?]) 
    else
      file << "  return cmock_call_instance->ReturnVal;\n" unless (function[:return][:void?]) 
    end
    file << "}\n\n"

    expect_result(file, function)
    reset_expect_result(file, function)
  end

  def expect_result(file, function)
    file << "#{@api} int #{function[:name]}_CMockExpectedResult()\n{\n"
    file << "  if (CMOCK_#{function[:name]}_EXPECT_RESULT.ExpectCalled == 1)\n  {\n"
    file << @plugins.run(:expect_declaration, function)
    file << "  }\n"
    file << "  return 0; // Function has not been called, nor is it expected to. \n}\n\n"
  end

  #
  #
  #
  #
  #
  def reset_expect_result(file, function)
    file << "#{@api} void #{function[:name]}_CMockResetExpectedResult()\n{\n"
    file << "  CMOCK_#{function[:name]}_EXPECT_RESULT.ExpectCalled = 0;\n"
    file << @plugins.run(:expect_reset_arguments, function)
    file << "}\n\n"
  end

  #
  #
  #
  #
  #
  def create_mock_interfaces(file, function)
    file << @utils.code_add_argument_loader(function)
    file << @plugins.run(:mock_interfaces, function)
  end

  def preprocessor_formatting(function)
    definition = function[:defs].to_s
    # List of substitutions to format the preprocessor statement correctly.
    definition.gsub!(/\[/,'')
    definition.gsub!(/\]/,'')
    definition.gsub!(/"/,'')
    definition.gsub!(/,/,'')

    # Split lines by statement.
    definition.gsub!(/#/,"\n#")

    # Removes includes statements, these should be in the header already.
    definition.gsub!(/<\D*\d*>/, '')
    definition.gsub!(/\\\D*\d*\\/, '')
    definition.gsub!(/^#include\s/,'')

    # Correction in case endif # has been removed.
    definition.gsub!(/^endif/,"#endif")

    return definition
  end

  def filename_format(function)

    # Filename has been appended to each function. This formats to a suitable comparator.
    file_name = function[:filename]
    file_name = file_name.gsub(".C",'')

    # Fixes to get the comparison working.
    #file_name = file_name.gsub("_INTRINSICS",'')
    #file_name = file_name.gsub("_INTRINISCS",'')
    #file_name = "#ifndef _" + file_name

    if(file_name.match("EPSGSPACECONV_INTRINSICS"))
      file_name = "_EPSGSPACECONV"
    elsif(file_name.match("D3EDITOP_INTRINSICS"))
      file_name = "D3EDITOP_INTRINISCS"
    end

    return file_name
  end
end
